package template

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	. "github.com/dave/jennifer/jen"
	mstrings "github.com/devimteam/microgen/generator/strings"
	"github.com/devimteam/microgen/generator/write_strategy"
	"github.com/devimteam/microgen/logger"
	"github.com/vetcher/go-astra/types"
)

const (
	GolangProtobufPtypesTimestamp = "github.com/golang/protobuf/ptypes/timestamp"
	JsonbPackage                  = "github.com/sas1024/gorm-jsonb/jsonb"
	GolangProtobufPtypes          = "github.com/golang/protobuf/ptypes"
	GolangProtobufWrappers        = "github.com/golang/protobuf/ptypes/wrappers"
)

type stubGRPCTypeConverterTemplate struct {
	info                      *GenerationInfo
	alreadyRenderedConverters []string
	state                     WriteStrategyState
}

func NewStubGRPCTypeConverterTemplate(info *GenerationInfo) Template {
	return &stubGRPCTypeConverterTemplate{
		info: info,
	}
}

func specialTypeConverter(p types.Type) *Statement {
	name := types.TypeName(p)
	imp := types.TypeImport(p)
	// error -> string
	if name != nil && *name == "error" && imp == nil {
		return Id("string")
	}
	// time.Time -> timestamp.Timestamp
	if name != nil && *name == "Time" && imp != nil && imp.Package == "time" {
		if types.TypeArray(p) == nil { // ignore []time.Time case
			return Op("*").Qual(GolangProtobufPtypesTimestamp, "Timestamp")
		}
	}
	// jsonb.JSONB -> string
	if name != nil && *name == "JSONB" && imp != nil && imp.Package == JsonbPackage {
		return Id("string")
	}
	// *string -> *wrappers.StringValue
	if name != nil && *name == "string" && imp == nil {
		_, ok := p.(types.TPointer)
		if ok {
			return Op("*").Qual(GolangProtobufWrappers, "StringValue")
		}
	}
	// *float64 -> *wrappers.DoubleValue
	if name != nil && *name == "float64" && imp == nil {
		ptr, ok := p.(types.TPointer)
		if ok && ptr.NumberOfPointers == 1 {
			return Op("*").Qual(GolangProtobufWrappers, "DoubleValue")
		}
	}
	return nil
}

func converterToProtoBody(field *types.Variable) Code {
	s := &Statement{}
	switch typeToProto(field.Type, 0) {
	case "ErrorToProto":
		s.If(Id(mstrings.ToLowerFirst(field.Name))).Op("==").Nil().Block(
			Return().List(Lit(""), Nil()),
		).Line()
		s.Return().List(Id(mstrings.ToLowerFirst(field.Name)).Dot("Error").Call(), Nil())
	case "ByteListToProto", "ListByteToProto":
		s.Return().List(Id(mstrings.ToLowerFirst(field.Name)), Nil())
	case "TimeTimeToProto":
		s.Return().Qual(GolangProtobufPtypes, "TimestampProto").Call(Id(field.Name))
	case "ListStringToProto", "SliceStringToProto":
		s.Return().List(Id(mstrings.ToLowerFirst(field.Name)), Nil())
	//	if str == "" {
	//		return nil
	//	}
	//	return &wrappers.StringValue{Value: str}
	case "PtrStringToProto":
		s.If(Id(mstrings.ToLowerFirst(field.Name)).Op("==").Nil()).Block(
			Return().List(Nil(), Nil()),
		)
		s.Line().Return().List(Op("&").Qual(GolangProtobufWrappers, "StringValue").Block(Dict{Id("Value"): Op("*").Id(mstrings.ToLowerFirst(field.Name)).Op(",")}), Nil())
	default:
		s.Panic(Lit("function not provided")).Comment("// TODO: provide converter")
	}
	return s
}

func converterProtoToBody(field *types.Variable) Code {
	s := &Statement{}
	switch protoToType(field.Type, 0) {
	case "ProtoToError":
		s.If().Id("proto" + mstrings.ToUpperFirst(field.Name)).Op("==").Lit("").Block(
			Return().List(Nil(), Nil()),
		).Line()
		s.Return().List(Qual("errors", "New").Call(Id("proto"+mstrings.ToUpperFirst(field.Name))), Nil())
	case "ProtoToByteList", "ProtoToListByte":
		s.Return().List(Id("proto"+mstrings.ToUpperFirst(field.Name)), Nil())
	case "ProtoToTimeTime":
		s.Return().Qual(GolangProtobufPtypes, "Timestamp").Call(Id("proto" + mstrings.ToUpperFirst(field.Name)))
	case "ProtoToListString", "ProtoToSliceString":
		s.Return().List(Id("proto"+mstrings.ToUpperFirst(field.Name)), Nil())
	case "ProtoToPtrString":
		s.If(Id("proto" + mstrings.ToUpperFirst(field.Name)).Op("==").Nil()).Block(
			Return().List(Nil(), Nil()),
		)
		s.Line().Return().List(Op("&").Id("proto"+mstrings.ToUpperFirst(field.Name)).Dot("Value"), Nil())
	default:
		s.Panic(Lit("function not provided")).Comment("// TODO: provide converter")
	}
	return s
}

// Render whole file with protobuf converters.
//
//		// This file was automatically generated by "microgen" utility.
//		package protobuf
//
//		func IntListToProto(positions []int) (protoPositions []int64, convPositionsErr error) {
//			panic("method not provided")
//		}
//
//		func ProtoToIntList(protoPositions []int64) (positions []int, convPositionsErr error) {
//			panic("method not provided")
//		}
//
func (t *stubGRPCTypeConverterTemplate) Render(ctx context.Context) write_strategy.Renderer {
	f := &Statement{}

	for _, signature := range t.info.Iface.Methods {
		if !t.info.AllowedMethods[signature.Name] {
			continue
		}
		args := append(RemoveContextIfFirst(signature.Args), removeErrorIfLast(signature.Results)...)
		for _, field := range args {
			if _, ok := golangTypeToProto(ctx, "", &field); !ok && !mstrings.IsInStringSlice(typeToProto(field.Type, 0), t.alreadyRenderedConverters) {
				f.Line().Add(t.stubConverterToProto(ctx, &field)).Line()
				t.alreadyRenderedConverters = append(t.alreadyRenderedConverters, typeToProto(field.Type, 0))
			}
			if _, ok := protoTypeToGolang(ctx, "", &field); !ok && !mstrings.IsInStringSlice(protoToType(field.Type, 0), t.alreadyRenderedConverters) {
				f.Line().Add(t.stubConverterProtoTo(ctx, &field)).Line()
				t.alreadyRenderedConverters = append(t.alreadyRenderedConverters, protoToType(field.Type, 0))
			}
		}
	}

	if t.state == AppendStrat {
		return f
	}

	file := NewFile("transportgrpc")
	file.ImportAlias(t.info.ProtobufPackageImport, "pb")
	file.ImportAlias(t.info.SourcePackageImport, serviceAlias)
	file.HeaderComment(t.info.FileHeader)
	file.PackageComment(`It is better for you if you do not change functions names!`)
	file.PackageComment(`This file will never be overwritten.`)
	file.Add(f)

	return file
}

func (stubGRPCTypeConverterTemplate) DefaultPath() string {
	return filenameBuilder(PathTransport, "grpc", "protobuf_type_converters")
}

func (t *stubGRPCTypeConverterTemplate) Prepare(ctx context.Context) error {
	if t.info.ProtobufPackageImport == "" {
		return fmt.Errorf("protobuf package is empty")
	}
	return nil
}

func (t *stubGRPCTypeConverterTemplate) ChooseStrategy(ctx context.Context) (write_strategy.Strategy, error) {
	if err := statFile(t.info.OutputFilePath, t.DefaultPath()); os.IsNotExist(err) {
		t.state = FileStrat
		return write_strategy.NewCreateFileStrategy(t.info.OutputFilePath, t.DefaultPath()), nil
	}
	file, err := parsePackage(filepath.Join(t.info.OutputFilePath, t.DefaultPath()))
	if err != nil {
		logger.Logger.Log(0, "can't parse", t.DefaultPath(), ":", err)
		return write_strategy.NewNopStrategy("", ""), nil
	}

	for i := range file.Functions {
		t.alreadyRenderedConverters = append(t.alreadyRenderedConverters, file.Functions[i].Name)
	}

	t.state = AppendStrat
	return write_strategy.NewAppendToFileStrategy(t.info.OutputFilePath, t.DefaultPath()), nil
}

// Render stub method for golang to protobuf converter.
//
//		func IntListToProto(positions []int) (protoPositions []int64, convPositionsErr error) {
//			return
//		}
//
func (t *stubGRPCTypeConverterTemplate) stubConverterToProto(ctx context.Context, field *types.Variable) *Statement {
	return Func().Id(typeToProto(field.Type, 0)).
		Params(Id(mstrings.ToLowerFirst(field.Name)).Add(fieldType(ctx, field.Type, false))).
		Params(Add(t.protoFieldType(ctx, field.Type)), Error()).
		Block(converterToProtoBody(field))
}

// Render stub method for protobuf to golang converter.
//
//		func ProtoToIntList(protoPositions []int64) (positions []int, convPositionsErr error) {
//			return
//		}
//
func (t *stubGRPCTypeConverterTemplate) stubConverterProtoTo(ctx context.Context, field *types.Variable) *Statement {
	return Func().Id(protoToType(field.Type, 0)).
		Params(Id("proto"+mstrings.ToUpperFirst(field.Name)).Add(t.protoFieldType(ctx, field.Type))).
		Params(Add(fieldType(ctx, field.Type, false)), Error()).
		Block(converterProtoToBody(field))
}

// Render protobuf field type for given func field.
//
//  	*repository.Visit
//
func (t *stubGRPCTypeConverterTemplate) protoFieldType(ctx context.Context, field types.Type) *Statement {
	c := &Statement{}
	if code := specialTypeConverter(field); code != nil {
		return c.Add(code)
	}
	custom := false
	for field != nil {
		switch f := field.(type) {
		case types.TImport:
			if f.Import != nil {
				c.Qual(t.info.ProtobufPackageImport, "")
				custom = true
			}
			field = f.Next
		case types.TName:
			protoType := f.TypeName
			if tmp, ok := goToProtoTypesMap[f.TypeName]; ok {
				protoType = tmp
				custom = true
			}
			if !custom && !types.IsBuiltin(f) {
				c.Qual(t.info.ProtobufPackageImport, protoType)
			} else {
				c.Id(protoType)
			}
			field = nil
		case types.TArray:
			if f.IsSlice {
				c.Index()
			} else if f.ArrayLen > 0 {
				c.Index(Lit(f.ArrayLen))
			}
			field = f.Next
		case types.TMap:
			return c.Map(t.protoFieldType(ctx, f.Key)).Add(t.protoFieldType(ctx, f.Value))
		case types.TPointer:
			c.Op(strings.Repeat("*", f.NumberOfPointers))
			field = f.Next
		case types.TInterface:
			mhds := interfaceType(ctx, f.Interface)
			return c.Interface(mhds...)
		case types.TEllipsis:
			c.Index()
			field = f.Next
		default:
			return c
		}
	}

	return c
}
