package template

import (
	"github.com/devimteam/microgen/util"
	"github.com/vetcher/godecl/types"
	. "github.com/vetcher/jennifer/jen"
)

const (
	GolangProtobufPtypesTimestamp = "github.com/golang/protobuf/ptypes/timestamp"
	JsonbPackage                  = "github.com/sas1024/gorm-jsonb/jsonb"
)

func specialTypeConverter(p *types.Type) *Statement {
	// error -> string
	if p.Name == "error" && p.Import == nil {
		return (&Statement{}).Id("string")
	}
	// time.Time -> timestamp.Timestamp
	if p.Name == "Time" && p.Import != nil && p.Import.Package == "time" {
		return (&Statement{}).Qual(GolangProtobufPtypesTimestamp, "Timestamp")
	}
	// jsonb.JSONB -> string
	if p.Name == "JSONB" && p.Import != nil && p.Import.Package == JsonbPackage {
		return (&Statement{}).Id("string")
	}
	return nil
}

func converterToProtoBody(field *types.Variable) Code {
	s := &Statement{}
	switch typeToProto(&field.Type, 0) {
	case "ErrorToProto":
		s.If().Id(util.ToLowerFirst(field.Name)).Op("==").Nil().Block(
			Return().List(Lit(""), Nil()),
		).Line()
		s.Return().List(Id(util.ToLowerFirst(field.Name)).Dot("Error").Call(), Nil())
	case "ByteListToProto":
		s.Return().List(Id(util.ToLowerFirst(field.Name)), Nil())
	default:
		s.Panic(Lit("method not provided"))
	}
	return s
}

func converterProtoToBody(field *types.Variable) Code {
	s := &Statement{}
	switch protoToType(&field.Type, 0) {
	case "ProtoToError":
		s.If().Id("proto" + util.ToUpperFirst(field.Name)).Op("==").Lit("").Block(
			Return().List(Nil(), Nil()),
		).Line()
		s.Return().List(Qual("errors", "New").Call(Id("proto"+util.ToUpperFirst(field.Name))), Nil())
	case "ProtoToByteList":
		s.Return().List(Id("proto"+util.ToLowerFirst(field.Name)), Nil())
	default:
		s.Panic(Lit("method not provided"))
	}
	return s
}

type stubGRPCTypeConverterTemplate struct {
	Info                      *GenerationInfo
	alreadyRenderedConverters []string
}

func NewStubGRPCTypeConverterTemplate(info *GenerationInfo) *stubGRPCTypeConverterTemplate {
	return &stubGRPCTypeConverterTemplate{
		Info: info.Duplicate(),
	}
}

// Render whole file with protobuf converters.
//
//		// This file was automatically generated by "microgen" utility.
//		package protobuf
//
//		func IntListToProto(positions []int) (protoPositions []int64, convPositionsErr error) {
//			panic("method not provided")
//		}
//
//		func ProtoToIntList(protoPositions []int64) (positions []int, convPositionsErr error) {
//			panic("method not provided")
//		}
//
func (t *stubGRPCTypeConverterTemplate) Render(i *GenerationInfo) *Statement {
	f := Statement{}

	for _, signature := range i.Iface.Methods {
		args := append(removeContextIfFirst(signature.Args), removeContextIfFirst(signature.Results)...)
		for _, field := range args {
			if _, ok := golangTypeToProto("", &field); !ok && !util.IsInStringSlice(typeToProto(&field.Type, 0), t.alreadyRenderedConverters) {
				f.Add(t.stubConverterToProto(&field)).Line().Line()
				t.alreadyRenderedConverters = append(t.alreadyRenderedConverters, typeToProto(&field.Type, 0))
				f.Add(t.stubConverterProtoTo(&field)).Line().Line()
				t.alreadyRenderedConverters = append(t.alreadyRenderedConverters, protoToType(&field.Type, 0))
			}
		}
	}

	return &f
}

func (stubGRPCTypeConverterTemplate) DefaultPath() string {
	return "./transport/converter/protobuf/type_converters.go"
}

// Render stub method for golang to protobuf converter.
//
//		func IntListToProto(positions []int) (protoPositions []int64, convPositionsErr error) {
//			return
//		}
//
func (t *stubGRPCTypeConverterTemplate) stubConverterToProto(field *types.Variable) *Statement {
	return Func().Id(typeToProto(&field.Type, 0)).
		Params(Id(util.ToLowerFirst(field.Name)).Add(fieldType(&field.Type))).
		Params(Id("proto"+util.ToUpperFirst(field.Name)).Add(t.protoFieldType(&field.Type)), Id("conv"+util.ToUpperFirst(field.Name)+"Err").Error()).
		Block(converterToProtoBody(field))
}

// Render stub method for protobuf to golang converter.
//
//		func ProtoToIntList(protoPositions []int64) (positions []int, convPositionsErr error) {
//			return
//		}
//
func (t *stubGRPCTypeConverterTemplate) stubConverterProtoTo(field *types.Variable) *Statement {
	return Func().Id(protoToType(&field.Type, 0)).
		Params(Id("proto"+util.ToUpperFirst(field.Name)).Add(t.protoFieldType(&field.Type))).
		Params(Id(util.ToLowerFirst(field.Name)).Add(fieldType(&field.Type)), Id("conv"+util.ToUpperFirst(field.Name)+"Err").Error()).
		Block(converterProtoToBody(field))
}

// Render protobuf field type for given func field.
//
//  	*repository.Visit
//
func (t *stubGRPCTypeConverterTemplate) protoFieldType(field *types.Type) *Statement {
	c := &Statement{}

	if field.IsArray {
		c.Index()
	}

	if field.IsPointer {
		c.Op("*")
	}

	if field.IsMap {
		m := field.Map()
		return c.Map(t.protoFieldType(&m.Key)).Add(t.protoFieldType(&m.Value))
	}
	if field.IsInterface {
		c.Interface()
	}
	protoType := field.Name
	if tmp, ok := goToProtoTypesMap[field.Name]; ok {
		protoType = tmp
	}
	if code := specialTypeConverter(field); code != nil {
		return c.Add(code)
	}
	if field.Import != nil {
		c.Qual(protobufPath(t.Info.ServiceImportPackageName), protoType)
	} else {
		c.Id(protoType)
	}

	return c
}
