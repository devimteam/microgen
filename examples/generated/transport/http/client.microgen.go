// Code generated by microgen 0.9.0. DO NOT EDIT.

package transporthttp

import (
	transport "github.com/devimteam/microgen/examples/generated/transport"
	endpoint "github.com/go-kit/kit/endpoint"
	log "github.com/go-kit/kit/log"
	sd "github.com/go-kit/kit/sd"
	lb "github.com/go-kit/kit/sd/lb"
	opentracing "github.com/go-kit/kit/tracing/opentracing"
	httpkit "github.com/go-kit/kit/transport/http"
	opentracinggo "github.com/opentracing/opentracing-go"
	"io"
	"net/url"
)

func NewHTTPClient(u *url.URL, opts ...httpkit.ClientOption) transport.EndpointsSet {
	return transport.EndpointsSet{
		CountEndpoint: httpkit.NewClient(
			"GET", u,
			_Encode_Count_Request,
			_Decode_Count_Response,
			opts...,
		).Endpoint(),
		DummyMethodEndpoint: httpkit.NewClient(
			"POST", u,
			_Encode_DummyMethod_Request,
			_Decode_DummyMethod_Response,
			opts...,
		).Endpoint(),
		TestCaseEndpoint: httpkit.NewClient(
			"POST", u,
			_Encode_TestCase_Request,
			_Decode_TestCase_Response,
			opts...,
		).Endpoint(),
		UppercaseEndpoint: httpkit.NewClient(
			"POST", u,
			_Encode_Uppercase_Request,
			_Decode_Uppercase_Response,
			opts...,
		).Endpoint(),
	}
}

func TracingHTTPClientOptions(tracer opentracinggo.Tracer, logger log.Logger) func([]httpkit.ClientOption) []httpkit.ClientOption {
	return func(opts []httpkit.ClientOption) []httpkit.ClientOption {
		return append(opts, httpkit.ClientBefore(
			opentracing.ContextToHTTP(tracer, logger),
		))
	}
}

// NewHTTPClientSD is a http client for StringService and uses service discovery inside.
var NewHTTPClientSD = sdClientFactory(httpClientFactoryMaker)

// sdClientFactory is a factory to create constructors for HTTPClientSD
func sdClientFactory(
	maker func(opts ...httpkit.ClientOption) func(string) (transport.EndpointsSet, error),
) func(sd.Instancer, log.Logger, ...httpkit.ClientOption) transport.EndpointsSet {
	return func(instancer sd.Instancer, logger log.Logger, opts ...httpkit.ClientOption) transport.EndpointsSet {
		var endpoints transport.EndpointsSet
		{
			endpointer := sd.NewEndpointer(instancer, uppercaseSDFactory(maker(opts...)), logger)
			endpoints.UppercaseEndpoint, _ = lb.NewRoundRobin(endpointer).Endpoint()
		}
		{
			endpointer := sd.NewEndpointer(instancer, countSDFactory(maker(opts...)), logger)
			endpoints.CountEndpoint, _ = lb.NewRoundRobin(endpointer).Endpoint()
		}
		{
			endpointer := sd.NewEndpointer(instancer, testCaseSDFactory(maker(opts...)), logger)
			endpoints.TestCaseEndpoint, _ = lb.NewRoundRobin(endpointer).Endpoint()
		}
		{
			endpointer := sd.NewEndpointer(instancer, dummyMethodSDFactory(maker(opts...)), logger)
			endpoints.DummyMethodEndpoint, _ = lb.NewRoundRobin(endpointer).Endpoint()
		}
		return endpoints
	}
}

// httpClientFactoryMaker returns function, that describes what to do with `instance string` to create new instance of client.
// Commonly, for http protocol it would be some sort of url, e.g. `host:port`.
func httpClientFactoryMaker(opts ...httpkit.ClientOption) func(string) (transport.EndpointsSet, error) {
	return func(instance string) (transport.EndpointsSet, error) {
		u, err := url.Parse(instance)
		if err != nil {
			return transport.EndpointsSet{}, err
		}
		return NewHTTPClient(u, opts...), nil
	}
}
func uppercaseSDFactory(clientMaker func(string) (transport.EndpointsSet, error)) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		c, err := clientMaker(instance)
		return c.UppercaseEndpoint, nil, err
	}
}
func countSDFactory(clientMaker func(string) (transport.EndpointsSet, error)) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		c, err := clientMaker(instance)
		return c.CountEndpoint, nil, err
	}
}
func testCaseSDFactory(clientMaker func(string) (transport.EndpointsSet, error)) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		c, err := clientMaker(instance)
		return c.TestCaseEndpoint, nil, err
	}
}
func dummyMethodSDFactory(clientMaker func(string) (transport.EndpointsSet, error)) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		c, err := clientMaker(instance)
		return c.DummyMethodEndpoint, nil, err
	}
}
